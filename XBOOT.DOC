XBoot 2.0 (c) 1996 by EBCEEB, inc.
Краткая документация от 14 августа
▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀

1. Совсем коротко
~~~~~~~~~~~~~~~~~
   XBoot является усовершенствованным вариантом программы BootAny.
BootAny - это один из самых первых и простых Boot-менеджеров.
Он настолько ретиво сопротивлялся всем попыткам улучшить его,
что пришлось мне оставить от него только идею да кое-какие
идентификаторы. В итоге получился скромный загрузчик с жесткого
диска, позволяющий на выбор запускать до трех операционных систем.


2. Теория
~~~~~~~~~
   Жесткий диск делится на разделы: первичные и вторичные (всего не более 4).
Первичных может быть несколько (очевидно, до 3-х), и в каждом сидит по систем-
ному диску. Вторичный, наоборот, может быть только один, зато в нем находятся
все несистемные логические диски.
   Программа POST читает с винчестера сектор 0-0-1, называемый Master Boot
Record (MBR); в нем сидит внесистемный загрузчик и таблица разделов (partition
table). Загрузчик читает таблицу, по ней узнает адрес текущего системного заг-
рузчика, читает его вместо себя по адресу 0:7C00 и передает ему управление.
   Разделение диска организуется ДОСовской программой FDISK, а текущий раздел
меняется DiskEdit'ом (Object/Partition table или Alt-A). Записать MBR в файл
можно тем же DiskEdit'ом, а лучше DiskTool'ом (Create/Restore rescue diskette).
В последних версиях NU этим занимается программа Rescue.
   BootAny вместо автоматической выборки текущего раздела выводил меню с их
названиями и ждал нажатия клавиши 5 секунд, после чего запускал систему с теку-
щего раздела. Его автор (не оставивший в документации ни имени, ни фамилии,
ни кликухи) втиснул в 01BEh байт меню, собственные данные, и прибамбасы вроде
все той же пятисекундной задержки. В результате появилась возможность в момент
загрузки выбирать одну из нескольких операционных систем.


3. А зачем ?
~~~~~~~~~~~~
  Это уж Вам лучше знать. Автор BootAny предлагал использовать свое творение
для переключения между DOS и OS/2. Я же после некоторого раздумья пришел
к такому выводу: если у Вас на машине установлены две системы разного уровня
(Unix+DOS или OS/2+DOS или NetWare+DOS), то лучше всего воспользоваться
Boot-менеджером, входящим в состав системы высокого уровня. Если Вам нужно
держать несколько систем одного уровня (Windows+Unix или DOS+DRDOS), исполь-
зуйте XBOOT. Лично я установил его, потому что на трех моих системных дисках
прочно обосновались 3 операционки: OS/2 3.0 Warp (+ PC DOS 7.0), Windows 95
(+ MS DOS 6.22) и Linux, и время от времени возникает необходимость работать
с каждой из них.


4. Отличия от BOOTANY и прочих аналогов
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  И впрямь, проще сказать, чего я в нем не менял. Доходило до абсурда - TASM
делал другой код, нежели MASM (отличия в одной команде), и от этого BootAny
начинал глюковать !:-Z, потом еще ...  Словом, нахлебался я горюшка. Теперь:

A) Меню запускается только при нажатом ALT, иначе запускается система
с текущего первичного раздела (т.е., как обычно)

B) Соответственно, убраны игры с таймером - если уж меню выводится,
то не исчезнет вплоть до нажатия допустимой клавиши

C) Убран выход к встроенному BASIC'у, ибо я его ни разу не встречал

D) Если не найден ни один загружаемый раздел, выводится текст и система
"встает". Загрузчик, устанавливаемый FDISK'ом, имеет такую возможность,
а BOOTANY - нет.

E) XBOOT не гадит в таблицу разделов, а все необходимые данные содержит
только внутри своего кода. Соответственно, стали ненужными всякие примочки
типа PREINST и PREFINST, входившие в BOOTANY, которые модифицировали
и проверяли состояние таблицы. Инсталлятор теперь безвредно можно
запускать несколько раз подряд.

F) Написан навороченный инсталлятор (XBOOT.EXE). В принципе, конечному
пользователю нужен только один этот файл.

G) При нажатом CTRL пытался XBOOT загрузить систему с диска B:, и все бы
ничего, да вот только система начинает искать себя на диске A:, так что
эту оригинальную возможность пришлось мне закомментировать. Я с ней
так и не разобрался.

H) Master Boot Manager, поставляемый с OS/2, занимает на диске 1 метр!!
и уменьшает максимальное количество системных дисков с 3 до 2 (одну запись
в таблице разделов он реквизирует под собственные нужды). Мой XBOOT,
как и BootAny, целиком умещается в загрузочном секторе и пространства
вне его не требует.

I) Неплохой Master Boot Manager из состава Linux может делать примерно
то же самое, но имеет три недостатка:
  - сложнее устанавливается (особенно новичком :);
  - вместо нажатия F1/F2/F3 надо вводить имя раздела + <Enter>;
  - не умеет маскировать системные диски на время их неактивности
    (несистемности).
  Да и Linux не у каждого есть.


5. Файлы и программы
~~~~~~~~~~~~~~~~~~~~
MAKEFILE     - тупой проект для утилиты MAKE
XBOOT.ASM    - исходный текст внесистемного загрузчика
XBOOT.DOC    - этот файл
XBOOT.PAS    - исходный текст инсталлятора / настройщика
XBOOT.EXE    - инсталлятор / настройщик (содержит в себе образ нового MBR)
DBG.ASM      - позволяет трассировать MBR отладчиком, не делая перезагрузки
TAKEMEM.PAS  - захватывает кусок памяти указанного размера,
               нужен для резервирования памяти в диапазоне 07C00..08000
FLOPBOOT.PAS - простой установщик нового Boot-сектора для гибких дисков
*._A_        - Различные Boot-секторы в двоичном виде (см. описание FLOPBOOT)

  Конечному пользователю требуются только XBOOT.EXE и, разумеется, XBOOT.DOC.
  Для работы над исходниками требуются:
Программы:  PKLITE, BINOBJ, MAKE, TASM, TLINK, TDSTRIP, Turbo Pascal 7.0
Желательно: TechHelp 6.0,
            AT86 фирмы Morgan Computing, или DeGlucker 0.02,
            или другой, не менее крутой отладчик.


6. Как сделать несколько ДОСовских дисков C: (т.е. системных) ?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Эта главка относится только к тем, кто имеет изначально только DOS,
а также программу FDISK из ее состава.

A) Запустить FDISK, все на винчестере постирать...
B) ...и создать первичный раздел
C) Oтформатировать появившийся диск C:, разместить на нем систему
D) Программой DiskEdit в просмотре Partition table пометить его как BBT.
E) Выполнить шаги B, C, D, B.
F) Создать расширенный раздел, в нем - логические диски (будут именоваться,
   начиная с D:)
E) Выполнить шаг C
F) Отформатировать остальные досовские диски.

В итоге у Вас появятся 3 системных диска, один из которых в таблице разделов
(Partition table в DiskEdit) обозначен правильно (DOS-12, или DOS-16, или
BIGDOS; Boot=Yes), а два других скрыты под липовыми типами (BBT). Теперь
осталось лишь запустить XBOOT, как это написано в следующем разделе.

Что будет, если не помечать диск липовым типом ? FDISK просто не даст Вам
сделать новый первичный раздел, говоря, что один уже есть, а больше, мол,
и не надо.

Что будет, если после пункта E прописать в Partition table истинные типы
вместо липовых ? Эти диски станут видимыми одновременно: активный системный
получает имя C:, неактивный становится D:, настоящий D: становится E: и так
далее. Поэтому неактивному системному досовскому разделу и присваивают липовый
тип вроде BBT - тогда остальные операционки его просто игнорируют.

Почему в качестве липового типа лучше не выбирать UNUSED ? Потому что
такую запись FDISK, да и не только он, будет воспринимать не как диск,
а как свободное, никаким диском не занятое пространство - и очень вероятно,
что что-нибудь на нем затрет.

Если у Вас есть LINUX, то...
...все делается намного проще, за один запуск тамошнего FDISK'а.
Конкретной системой (DOS или OS/2) остается только отформатировать
созданные для нее разделы (+ занести систему на системный раздел).

Если у Вас есть OS/2, то...
...наверное, все почти как в DOS'е. Точно сказать не могу,
ибо не экспериментировал.


7. Инсталляция
~~~~~~~~~~~~~~
A) Запустить DiskTool (или Rescue) и сделать копию "partition table"
   на гибком диске !!!!
B) Запустить XBOOT с ключом "//" (запишет в начало винчестера новый загрузчик)
C) Перезапуститься и нажать, как уже говорилось, ALT

  Перво-наперво на экране появится список констант, соответствующих
всем мне известным типам дисков. Константы предваряются знаком "$";
это значит, что они 16-ричные.

  Последовательно для всех четырех разделов XBOOT выводит:
A) Номер
B) Загружаемый он в данный момент или нет
C) Его тип (UNUSED, FAT-12, FAT-16, HPFS, ...)
   Если XBOOT уже был инсталлирован, и сейчас обнаружен в загрузочном секторе,
то тип диска берется не из Partition table, а из внутренних данных обнаружен-
ного загрузчика. Например, диск помечен в Partition table как BBT, в таблице
XBOOT - как FAT-16; значит, выведется FAT-16. См. также ключ "/i".
  Если раздел имеет тип EXTENDED, то XBOOT его пропускает, ибо такие разделы
  ("вторичные" или "расширенные") по определению не могут быть системными.
D) Иначе пользователю предлагается ввести название раздела (до 15 символов).
  Если ничего не вводить, то раздел будет пропущен. Позднее его можно будет
сделать системным, редактируя вручную Partition table посредством DiskEdit,
или переинсталлировав XBOOT.
  Введенный текст будет показан на экране по нажатию ALT в момент загрузки.
E) Затем нужно ввести новый тип диска (справка по типам выводится раньше).
  Если ничего не вводить, то тип останется каким был.
  Вместе со строкой описания введенный ИСТИННЫЙ тип будет сохранен
во внутренних данных загрузчика. В Partition table неактивный системный
диск получит тип BBT (см. ниже ключ "/h").

В любой точке можно нажать Control-Break - и спасти стартовый сектор
от порчи, если какие-то данные оказались введены неверно.


8. Отслеживание изменений в Partition table
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Бывает и такое, что данные о типах дисков во внутренней таблице XBOOT
перестают соответствовать тем, которые находятся в Partition table, например:
 - Вы поставили OS/2, и она диск C: переделала с FAT-16 в HPFS
 - Вы стерли OS/2 и переформатировали диск C: с HPFS в FAT-16
 - Установлен Linux, который занял одну из строк, помеченных ранее UNUSED,
   под свой раздел (т.н. "Linux native")
Следует использовать одно из двух:
 - Если изменились ИСТИННЫЕ ТИПЫ системных дисков, то следует
   запустить XBOOT с ключом "/r" (Refresh, т.е. "освежить" данные XBOOT
   данными из Partition table). Обновление выполняется раздельно для каждой
   строки внутренней таблицы загрузчика (требуется подтверждение Yes/No)
 - Если изменилось КОЛИЧЕСТВО системных дисков, то следует заново
   инсталлировать XBOOT. Для разделов, чьи типы изменились, их (типы)
   нужно ввести в последнем столбце.


9. Кое-что о ключах
~~~~~~~~~~~~~~~~~~~
  Ключ "//"
Служит для того, чтобы запустить инсталляцию с параметрами по умолчанию.
Если же вообще никаких параметров не указывать, то просто выведется подсказка.
  Ключ "/R" - Refresh
Используется, если после инсталляции XBOOT кто-то менял типы системных
разделов, участвующих в стартовом меню. Производит синхронизацию двух
таблиц.
  Ключ "/I" - Ignore
Используется при повторной инсталляции, если данные из внутренней таблицы
нужно проигнорировать.
  Ключ "/H" - Hidden id
Задает тип, которым надо помечать неактивные системные диски в Partition
table. По умолчанию: /H$FF (или /H255) - тип "BBT". Если задать "/H-1",
то неактивные системные диски маскироваться не будут. Это можно делать,
если операционки не норовят во время загрузки начать что-то читать с чужого
диска C:, например, в нижеприведенной таблице ни один диск маскировать
необязательно:
   1. BIGDOS       -- [C:] MS-DOS
   2. HPFS         -- [C:] OS/2 Warp
   3. Linux native -- [root] Linux
   4. EXTENDED     -- [D:] [E:] ...
А вот если есть два или три диска BIGDOS [C:], то маскировка неактивных
необходима. Про это было выше.


10. Алгоритм работы
~~~~~~~~~~~~~~~~~~~
  При старте MBR-загрузчик переписывает себя на 200 байт выше, дабы освободить
место для следующего Boot-сектора. Затем проверяется ALT - если он не нажат,
то по Partition table ищется раздел, у которого bootIndicator = 80h, с него
читается в 0:7C00 первый сектор и туда передается управление. Иначе читается
внутренняя таблица (ее тип обозван TPartData), из нее берутся строки для меню,
выводится меню, читается клавиша, определяется номер выбранного раздела, из него
с различными проверками читается Boot-сектор.
  Затем самое интересное: в Partition table у всех системных разделов
bootIndicator и тип раздела сбрасываются в n (см.Прим.). Тип выбранного раздела
восстанавливается из внутренних данных загрузчика, куда он записывается при ин-
сталляции. Этот тип напоследок переписывается в Partition table, а bootIndicator
взводится в 80h. Затем управление передается на уже считанный Boot-сектор.
  Видите, как все просто ?
  Прим.: n выбирается пользователем при инсталляции (ключ /H). По умолчанию
это код раздела для BBT - из-за нулевой распространенности этой малоизвестной
операционки. Если выбрать n = -1, то тип раздела меняться не будет вообще.


11. Проблемы при использовании
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Возникают в-основном оттого, что XBOOT может (по указанию пользователя)
помечать неиспользуемые системные диски для гарантии их невидимости
какой-бы то ни было операционкой как UNUSED.

A) Norton Disk Doctor (пробовалось с версией 6) имеет на сей счет глюк.
Отключите в его опциях проверку Partition table. На всякие вопросы о ней
не отвечайте ни "Yes", ни "No": он в обоих случаях гадил в MBR и вылетал
с Internal error; вместо этого давите на ESC и исправляйте его настройки.

B) FDISK любой операционной системы будет норовить создать диски на тех
местах, которые помечены как UNUSED. Трижды подумайте: действительно ли
это пустое место, обозначенное UNUSED, или на нем находится невидимый
в данный момент неактивный системный диск ?

А вот проблемы, вызванные тем, что не я один люблю писать в сектор 0-0-1...

C) Если Вы ставите систему, которая меняет тип диска (например, OS/2
с BIGDOS на HPFS) - запустите XBOOT с ключем /R, чтобы он мог обновить
данные о типе этого диска во ынутренней таблице XBOOT. То же самое
необходимо проделать, если тип диска меняется с помощью DiskEdit, или FDISK.

D) Если какая-то система (например, Linux) поставит свой загрузчик в MBR,
переинсталлируйте XBOOT поверх него. Правда, при этом есть риск, что предыдущий
загрузчик был слишком умным, и с его потерей стал невозможным доступ к тем
или иным данным, но меня, к счастью, до сих пор Бог берег от таких не в меру
умных загрузчиков... Между прочим, OS/2 Master Boot Manager таким примерно
и является. После его замены на XBOOT первичный раздел размером около 1MB
можно удалить, а пространство на винчестере и в MBR использовать под новый
диск, в частности, системный.

E) FDISK запросто может затереть код Мастер-загрузчика целиком. После этого
XBOOT придется переинсталлировать. Типичный пример: FDISK /MBR (не пробуйте!!)

Мелкие недостатки:

F) При чтении старых данных берется из MBR только тип диска, а описание
к нему всегда надо вводить заново, потому что старое описание не влезает
в экран по ширине.

G) Исходные тексты корявы до неприличия.

H) Отладка имела весьма поверхностный характер.


12. Бесплатное приложение: FLOPBOOT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Еще одна маленькая программка, успевшая устареть задолго до того, как была
задумана. Она переписывает Boot-сектор гибкого диска в/из файл на диске.
В принципе, эта возможность якобы существует в FFormat, да только (увы)
реализована она там с ошибкой. Вот и пришлось изобретать велосипед.
  Запуск FlopBoot без ключей выводит подсказку. Вот список ключей:
    /0 ... /3    - указать номер гибкого диска (0 - A, 1 - B, а 3 и 4,
                   как правило, никогда не занимаются). По умолчанию "/0"
    /d2 или /d3  - тип таблицы данных. Таблица сидит в начале Boot-сектора,
                   в разных версиях DOS она имеет разный размер. Этот ключ
                   указывает, сколько байт нужно оставлять неизменными
                   при записи нового загрузчика из файла на дискету
                   поверх существующего. По умолчанию используется размер
                   таблицы для DOS 4.0+. Лучше не балуйтесь с этим ключом.
    /r           - приказывает переписать Boot-сектор в файл. По умолчанию же
                   происходит нечто прямо противоположное.
    /s           - записать в Boot-сектор то, что записывают SYS и FORMAT,
                   то есть старый добрый DOS-овский загрузчик. FlopBoot
                   хранит его внутри себя.
    /y           - не выводить перед началом работы "Hit any key..."
                   и не ждать нажатия клавиши (специально для любителей
                   сначала сделать, а потом подумать, вроде меня)
    filename.ext - задает имя файла, который мы по умолчанию читаем,
                   а по "/r" пишем. Если не указывать ни "/r", ни "/s",
                   ни имени файла, то новый Boot-сектор для диска будет взят
                   из самого FlopBoot. Внутри FlopBoot хранится загрузчик
                   BOOT_HD.BSC, поставляемый в составе FFormat.
  Все параметры должны быть разделены пробелами, "/" разделителем не считается!
  Господин Шамароков, автор FFormat, чьи таланты я искренне и высоко ценю,
может здесь заметить, что программу его я не покупал, и таким образом, права
пользоваться загрузчиком не имею. Да только пусть он сначала ответит, заплатил
ли он хоть пфеннинг господину Christoph.H.HochstДtter'у, с FDBOOT.SYS которого
он передрал свой BOOT_HD до последней ассемблерной запятой. Только строчку
об авторских правах и не поленился переписать на свое имя, ухарь.
  Так что пользуйтесь на здоровье:
     format a: /t:80 /n:10 ...
     flopboot /0 /y

13. Напутственное резюме
~~~~~~~~~~~~~~~~~~~~~~~~
Вот такие вот пироги...


Илья Евсеев. 9 сентября 1996, Санкт-Петербург.
Адрес: 2:5030/445.8@fidonet.org

-END OF XBOOT.DOC-

Да, кстати...
  Менялись операционки, винт поменялся - обнаруживались и узости в XBOOT.
  Долго и нудно переделывалась документация - все она мне казалась
    недостаточно прозрачной. Даже и сейчас...
